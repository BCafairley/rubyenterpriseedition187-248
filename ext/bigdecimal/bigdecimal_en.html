<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html">
<style type="text/css"><!--
body {
  color: #3f0f0f;
  background: #fefeff;
  margin-left: 2em; margin-right: 2em;
}
h1 {
  color: #ffffff;
  background-color: #3939AD;
  border-color: #FF00FF;
  width: 100%;
  border-style: solid;
  border-top-width: 0.1em;
  border-bottom-width: 0.1em;
  border-right: none;
  border-left: none;
  padding: 0.1em;
  font-weight: bold;
  font-size: 160%;
  text-align: center;
}
h2 {
  color: #00007f;
  background-color: #e7e7ff;
  border-color: #000094;
  width: 100%;
  border-style: solid;
  border-left: none;
  border-right: none;
  border-top-width: 0.1em;
  border-bottom-width: 0.1em;
  padding: 0.1em;
  font-weight: bold;
  font-size: 110%;
}
h3 {
  color: #00007f;
  padding: 0.2em;
  font-size: 110%;
}
h4, h5 {
  color: #000000;
  padding: 0.2em;
  font-size: 100%;
}
table {
  margin-top: 0.2em; margin-bottom: 0.2em;
  margin-left: 2em; margin-right: 2em;
}
caption {
  color: #7f0000;
  font-weight: bold;
}
th {
  background: #e7e7ff;
  padding-left: 0.2em; padding-right: 0.2em;
}
td {
  background: #f3f7ff;
  padding-left: 0.2em; padding-right: 0.2em;
}
code {
  color: #0000df;
}
dt {
  margin-top: 0.2em;
}
li {
  margin-top: 0.2em;
}
pre
{
    BACKGROUND-COLOR: #d0d0d0;
    BORDER-BOTTOM: medium none;
    BORDER-LEFT: medium none;
    BORDER-RIGHT: medium none;
    BORDER-TOP: medium none;
    LINE-HEIGHT: 100%;
    MARGIN: 12px 12px 12px 12px;
    PADDING-BOTTOM: 12px;
    PADDING-LEFT: 12px;
    PADDING-RIGHT: 12px;
    PADDING-TOP: 12px;
    WHITE-SPACE: pre;
    WIDTH: 100%
}
--></style>

<TITLE>BigDecimal:An extension library for Ruby</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFE0>
<H1>BigDecimal(Variable Precision Floating Library for Ruby)</H1>
<DIV align="right"><A HREF="./bigdecimal_ja.html">Japanese</A></DIV><BR>
BigDecimal is an extension library for the Ruby interpreter. 
Using BigDecimal class, you can obtain any number of significant digits in computation. 
For the details about Ruby see:<BR>
<UL>
<LI><A HREF="http://www.ruby-lang.org/en/">http://www.ruby-lang.org/en/</A>:Official Ruby page(English).</LI>
<LI><A HREF="http://ruby.freak.ne.jp/">http://ruby.freak.ne.jp/</A>:Ruby informations(Japanese).</LI>
<LI><A HREF="http://kahori.com/ruby/ring/">http://kahori.com/ruby/ring/</A>:Mutually linked pages relating to Ruby(Japanese).
</LI>
</UL> 
NOTE:<BR>
 This software is provided "AS IS" and without any express or
 implied warranties,including,without limitation,the implied
 warranties of merchantibility and fitness for a particular
 purpose. For the details,see COPYING and README included in this
 distribution.
<BR>
<hr>

<H2>Contents</H2>
<UL>
<LI><A HREF="#INTRO">Introduction</LI>
<LI><A HREF="#SPEC">Usage and methods</A></LI>
<LI><A HREF="#UNDEF">Infinity,NaN,Zero</A></LI>
<LI><A HREF="#STRUCT">Internal structure</A></LI>
<LI><A HREF="#BASE">Binary or decimal number representation</A></LI>
<LI><A HREF="#PREC">Resulting number of significant digits</A></LI>
</UL>
<HR>

<A NAME="#INTRO">
<H2>Introduction</H2>
Ruby already has builtin (variable length integer number) class Bignum. Using Bignum class,you can obtain
 any integer value in magnitude. But, variable length floating number class is not yet built in. 
This is why I made variable length floating class BigDecimal.
Feel free to send any comments or bug reports to me.
<A HREF="mailto:shigeo@tinyforest.gr.jp">shigeo@tinyforest.gr.jp</A>
I will try(but can't promise) to fix bugs reported. 
<hr>
<H2>Installation</H2>
The Ruby latest version can be downloaded from <A HREF="http://www.ruby-lang.org/en/">Official Ruby page</A>.
Once decompress the downloaded Ruby archive,follow the normal installation procedures according to the 
documents included.

<A NAME="#SPEC">
<H2>Usage and methods</H2>
Suppose you already know Ruby programming,
to create BigDecimal objects,the program would like:<BR>

<CODE><PRE>
   require 'bigdecimal'
   a=BigDecimal::new("0.123456789123456789")
   b=BigDecimal::new("123456.78912345678",40)
   c=a+b
</PRE></CODE>

<H3>List of methods</H3>
In the following explanations,n specifies the minimum number of resulting significant digits,
not exactly but slightly excess memories will be allocated to newly created object.
In 32 bits integer system,every 4 digits(in decimal) are computed simultaneously.
This means the number of significant digits in BigDecimal is always a multiple of 4.

<UL>
<LI><B>new</B></LI><BR>
"new" method creates a new BigDecimal object.<BR>
a=BigDecimal::new(s[,n])<BR>
where:<BR>
s: Initial value string.<BR>
n: Maximum number of significant digits of a. n must be a Fixnum object.
If n is omitted or is equal to 0,then the maximum number of significant digits of a is determined from the length of s.

<LI><B>double_fig</B></LI><BR>
double_fig is a class method which returns the number of digits 
the Float class can have.
<CODE><PRE>
  p BigDecimal::double_fig  # ==> 20 (depends on the CPU etc.)
</PRE></CODE>
The equivalent C programs which calculates the value of
double_fig is:
<CODE><PRE>
 double v          = 1.0;
 int    double_fig = 0;
 while(v + 1.0 > 1.0) {
    ++double_fig;
    v /= 10;
 }
</PRE></CODE>

<LI><B>prec</B></LI><BR>
r,m = a.prec<BR>
where r is the number of significant digits of a,
m is the maximum number of significant digits a can hold.<br>
<CODE><PRE>
  require "bigdecimal"
  a = BigDecimal.new("0.12345")
  p a.prec                              # ==> [8, 12]
  b = BigDecimal.new("0.1234500000000")
  p b.prec                              # ==> [8, 20]
  c = BigDecimal.new("0.12345",20)
  p c.prec                              # ==> [8, 24]
</PRE></CODE>
r and m are always the multiple of log10(BigDecimal::BASE).

<LI><B>+</B></LI><BR>
addition(c = a + b)<BR>
For the resulting number of significant digits of c,see <A HREF="#PREC">Resulting number of significant digits</A>.

<LI><B>-</B></LI><BR>
subtraction (c = a - b) or negation (c = -a)<BR>
For the resulting number of significant digits of c,see <A HREF="#PREC">Resulting number of significant digits</A>.

<LI><B>*</B></LI><BR>
multiplication(c = a * b)<BR>
For the resulting number of significant digits of c,see <A HREF="#PREC">Resulting number of significant digits</A>.

<LI><B>/</B></LI><BR>
division(c = a / b)<BR>
For the resulting number of significant digits of c,see <A HREF="#PREC">Resulting number of significant digits</A>.

<LI><B>assign</B></LI><BR>
c = a.assign(n,f)<BR>
assigns the value of a to c.<BR>
n is the number of significant digits of resulting c.<BR>
If f > 0,then a is assigned to c.<BR>
If f < 0,then -a is assigned to c.<BR>
The absolute value of f (|f|) must be 1 or 2.
If |f|=2,then proper round operation over c is performed,when the maximum 
number of significant digits of c is less than current 
number of significant digits of a.
If |f|=1 then extra digits are discarded when the maximum 
number of significant digits of c is less than current 
number of significant digits of a.

<LI><B>add</B></LI><BR>
c = a.add(b,n)<BR>
c = a.add(b,n) performs c = a + b.
If n is less than the actual significant digits of a + b,
then c is rounded properly.

<LI><B>sub</B></LI><BR>
c = a.sub(b,n)<BR>
c = a.sub(b,n) performs c = a - b.
If n is less than the actual significant digits of a - b,
then c is rounded properly.

<LI><B>mult</B></LI><BR>
c = a.mult(b,n)<BR>
c = a.mult(b,n) performs c = a * b.
If n is less than the actual significant digits of a * b,
then c is rounded properly.

<LI><B>div</B></LI><BR>
c,r = a.div(b,n)<BR>
c,r = a.div(b,n) performs c = a / b, r is the residue of a / b.
If necessary,the divide operation continues to n digits which c
 can hold.
Unlike the divmod method,c is not always an integer.
c is never rounded,and the equation a = c*b + r is always 
valid unless c is NaN or Infinity.

<LI><B>%</B></LI><BR>
r = a%b <BR>
is the same as:<BR>
r = a-((a/b).floor)*b<BR>

<LI><B>fix</B></LI><BR>
c = a.fix<BR>
returns integer part of a.<BR>

<LI><B>frac</B></LI><BR>
c = a.frac<BR>
returns fraction part of a.<BR>

<LI><B>floor[(n)]</B></LI><BR>
c = a.floor<BR>
returns the maximum integer value (in BigDecimal) which is less than or equal to a.<BR>
As shown in the following example,an optional integer argument (n) specifying the position 
of 'floor'ed digit can be given.
If n> 0,then the (n+1)th digit counted from the decimal point in fraction part is 'floor'ed.
If n<0,then the n-th digit counted from the decimal point in integer part is 'floor'ed.<BR>

c = BigDecimal::new("1.23456")<BR>
d = c.floor(4) # d = 1.2345<BR>
c = BigDecimal::new("15.23456")<BR>
d = c.floor(-1) # d = 10.0<BR>

<LI><B>ceil[(n)]</B></LI><BR>
c = a.ceil<BR>
returns the minimum integer value (in BigDecimal) which is greater than or equal to a.<BR>
As shown in the following example,an optional integer argument (n) specifying the position 
of 'ceil'ed digit can be given.
If n>0,then the (n+1)th digit counted from the decimal point in fraction part is 'ceil'ed.
If n<0,then the n-th digit counted from the decimal point in integer part is 'ceil'ed.<BR>

c = BigDecimal::new("1.23456")<BR>
d = c.ceil(4) # d = 1.2346<BR>
c = BigDecimal::new("15.23456")<BR>
d = c.ceil(-1) # d = 20.0<BR>

<LI><B>round[(n)]</B></LI><BR>
c = a.round<BR>
round off a to the nearest 1ÅD<BR>
As shown in the following example,an optional integer argument (n) specifying the position 
of rounded digit can be given.
If n>0,then the (n+1)th digit counted from the decimal point in fraction part is rounded.
If n<0,then the n-th digit counted from the decimal point in integer part is rounded.<BR>

c = BigDecimal::new("1.23456")<BR>
d = c.round(4)  # d = 1.235 <BR>
c = BigDecimal::new("15.23456")<BR>
d = c.round(-1) # d = 20.0<BR>

<LI><B>truncate[(n)]</B></LI><BR>
c = a.truncate<BR>
truncate a to the nearest 1ÅD<BR>
As shown in the following example,an optional integer argument (n) specifying the position 
of truncated digit can be given.
If n>0,then the (n+1)th digit counted from the decimal point in fraction part is truncated.
If n<0,then the n-th digit counted from the decimal point in integer part is truncated.<BR>

c = BigDecimal::new("1.23456")<BR>
d = c.truncate(4)  # d = 1.2345<BR>
c = BigDecimal::new("15.23456")<BR>
d = c.truncate(-1) # d = 10.0<BR>

<LI><B>divmod</B></LI><BR>
c,r = a.divmod(b) # a = c*b + r<BR>
returns the quotient and remainder of a/b.<BR>
a = c * b + r is always satisfied.<BR>
where c is the integer sutisfying
c = (a/b).floor <BR>
and,therefore 
r = a - c*b<BR>

<LI><B>remainder</B></LI><BR>
r=a.remainder(b)<BR>
returns the remainder of a/b.<BR>
where c is the integer sutisfying 
c = (a/b).fix <BR>
and,therefore: 
r = a - c*b<BR>

<LI><B>abs</B></LI><BR>
c = a.abs<BR>
returns an absolute value of a.<BR>

<LI><B>to_i</B></LI><BR>
changes a to an integer.<BR>
i = a.to_i<BR>
i becomes to Fixnum or Bignum.
IF a is Infinity or NaN,then i becomes to nil.

<LI><B>to_s[(n)]</B></LI><BR>
converts to string(results look like "0.xxxxxEn").<BR>
s = a.to_s<BR>
If n is given,then a space is inserted after every n digits for readability.<BR>
s = a.to_s(n)

<LI><B>exponent</B></LI><BR>
returns an integer holding exponent value of a.<BR>
n = a.exponent <BR>
means a = 0.xxxxxxx*10**n.

<LI><B>to_f</B></LI><BR>
same as dup method.
creates a new BigDecimal object having same value.

<LI><B>E</B></LI><BR>
e = BigDecimal::E(n)<BR>
where e(=2.718281828....) is the base value of natural logarithm.<BR>
n specifies the length of significant digits of e.

<LI><B>PI</B></LI><BR>
e = BigDecimal::PI(n)<BR>
returns at least n digits of the ratio of the circumference of a circle to its dirmeter
(pi=3.14159265358979....) using J.Machin's formula.<BR>

<LI><B>BASE</B></LI><BR>
Base value used in the BigDecimal calculation.
On 32 bit integer system,the value of BASE is 10000.<BR>
b = BigDecimal::BASE<BR>

<LI><B>mode</B></LI><BR>
mode method controls BigDecimal computation.
Following usage are defined.<BR>

f = BigDecimal::mode(BigDecimal::EXCEPTION_NaN,flag)<BR>
f = BigDecimal::mode(BigDecimal::EXCEPTION_INFINITY,flag)<BR>
f = BigDecimal::mode(BigDecimal::EXCEPTION_UNDERFLOW,flag)<BR>
f = BigDecimal::mode(BigDecimal::EXCEPTION_OVERFLOW,flag)<BR>
f = BigDecimal::mode(BigDecimal::EXCEPTION_ZERODIVIDE,flag)<BR>
f = BigDecimal::mode(BigDecimal::EXCEPTION_ALL,flag)<BR>

EXCEPTION_NaN controls the execution once computation results to NaN.
EXCEPTION_INFINITY controls the execution once computation results to Infinity(Å}Infinity).
EXCEPTION_UNDERFLOW controls the execution once computation underflows.
EXCEPTION_OVERFLOW controls the execution once computation overflows.
EXCEPTION_ZERODIVIDE controls the execution once zero-division occures.
EXCEPTION_ALL controls the execution for any exception defined occures.
If the flag is true,then the relating exception is thrown.
No exception is thrown when the flag is false(default) and computation 
continues with the result:<BR>
EXCEPTION_NaN results to NaN<BR>
EXCEPTION_INFINITY results to +Infinity or -Infinity<BR>
EXCEPTION_UNDERFLOW results to 0.<BR>
EXCEPTION_OVERFLOW results to +Infinity or -Infinity<BR>
EXCEPTION_ZERODIVIDE results to +Infinity or -Infinity<BR>
EXCEPTION_INFINITY,EXCEPTION_OVERFLOW, and EXCEPTION_ZERODIVIDE are
 currently the same.<BR>
The return value of mode method is the value set.
Suppose the return value of the mode method is f,then 
 f & BigDecimal::EXCEPTION_NaN !=0 means EXCEPTION_NaN is set to on.
If the value of the argument flag is other than nil,true nor false then 
current mode status is returned.

<LI><B>limit[(n)]</B></LI><BR>
Limits the maximum digits that the newly created BigDecimal objects can hold
never exceed n. Returns maximum value before set.
Zero,the default value,means no upper limit.<BR>
mf = BigDecimal::limit(n)<BR>

<LI><B>sign</B></LI><BR>
returns the 'attribute'.
n = a.sign <BR>
where the value of n means that a is:<BR>
n = BigDecimal::SIGN_NaN(0) : a is NaN<BR>
n = BigDecimal::SIGN_POSITIVE_ZERO(1) : a is +0<BR>
n = BigDecimal::SIGN_NEGATIVE_ZERO(-1) : a is -0<BR>
n = BigDecimal::SIGN_POSITIVE_FINITE(2) : a is positive<BR>
n = BigDecimal::SIGN_NEGATIVE_FINITE(-2) : a is negative<BR>
n = BigDecimal::SIGN_POSITIVE_INFINITE(3) : a is +Infinity<BR>
n = BigDecimal::SIGN_NEGATIVE_INFINITE(-3) : a is -Infinity<BR>
The value in () is the actual value,see (<A HREF="#STRUCT">Internal structure</A>.<BR>

<LI><B>nan?</B></LI><BR>
a.nan? returns True when a is NaN.

<LI><B>infinite?</B></LI><BR>
a.infinite? returns True when a is +Åá or -Åá.

<LI><B>finite?</B></LI><BR>
a.finite? returns True when a is neither Åá nor NaN.

<LI><B>to_parts</B></LI><BR>
decomposes a BigDecimal value to 4 parts.
All 4 parts are returned as an array.<BR>
Parts consist of a sign(0 when the value is NaN,+1 for positive and
 -1 for negative value), a string representing fraction part,base value(always 10 currently),and an integer(Fixnum) for exponent respectively.
a=BigDecimal::new("3.14159265",10)<BR>
f,x,y,z = a.to_parts<BR>
where f=+1,x="314159265",y=10 and z=1<BR>
therefore,you can translate BigDecimal value to Float as:<BR>
s = "0."+x<BR>
b = f*(s.to_f)*(y**z)<BR>

<LI><B>inspect</B></LI><BR>
is used for debugging output.<BR>
p a=BigDecimal::new("3.14",10)<BR>
should produce output like "#&lt;0x112344:'0.314E1',4(12)%gt;".
where "0x112344" is the address,
'0.314E1' is the value,4 is the number of the significant digits,
and 12 is the maximum number of the significant digits 
the object can hold.

<LI><B>dup</B></LI><BR>
creates a new BigDecimal object having same value.

<LI><B>sqrt</B></LI><BR>
c = a.sqrt(n)<BR>
computes square root value of a with significant digit number n at least.<BR>

<LI><B>sincos</B></LI><BR>
computes and returns sine and cosine value of a with significant digit number n at least.<BR>
sin,cos = a.sincos(n)<BR>

<LI><B>exp</B></LI><BR>
c = a.exp(n)<BR>
computes the base of natural logarithm value(e=2.718281828....) powered by a
with significant digit number n at least.<BR>

<LI><B>power</B></LI><BR>
c = a.power(n)<BR>
returns the value of a powered by n(c=a**n).
n must be an integer.<BR>

<LI><B>zero?</B></LI><BR>
c = a.zero?<BR>
returns true if a is equal to 0,otherwise returns false<BR>

<LI><B>nonzero?</B></LI><BR>
c = a.nonzero?<BR>
returns false if a is 0,otherwise returns a itself.<BR>

<LI><B>&lt;=&gt;</B></LI><BR>
c = a &lt;=&gt; b <BR>
returns 0 if a==b,1 if a &gt b,and returns -1 if a &lt b.<BR>
</UL>

Following methods need no explanation.<BR>
<UL>
<LI>==</LI>
<LI>===</LI>
same as ==,used in case statement.
<LI>!=</LI>
<LI>&lt;</LI>
<LI>&lt;=</LI>
<LI>&gt;</LI>
<LI>&gt;=</LI>
</UL>
<HR>

<H3>About 'coerce'</H3>
<B>For the binary operation like A op B:</B>
<DL>
<DT> 1.Both A and B are BigDecimal objects</DT>
<DD> A op B is normally performed.</DD>
<DT> 2.A is the BigDecimal object but B is other than BigDecimal object</DT>
<DD> Operation is performed,after B is translated to correcponding BigDecimal object(because BigDecimal supports coerce method).</DD>
<DT> 3.A is not the BigDecimal object but B is BigDecimal object</DT>
<DD>If A has coerce mthod,then B will translate A to corresponding 
BigDecimal object and the operation is performed,otherwise an error occures.</DD>
</DL>

Attention must be paid when a String is to be translated to BigDecimal.
Translation stops without error at the character representing non digit.
For instance,"10XX" is translated to 10,"XXXX" is translated to 0.<BR>
String representing zero or infinity such as "Infinity","+Infinity","-Infinity",and "NaN" can also be translated to BigDecimal unless false is specified by mode method.<BR>

BigDecimal class supports coerce method(for the details about coerce method,see Ruby documentations). This means the most binary operation can be performed if the BigDecimal object is at the left hand side of the operation.<BR><BR>

 For example:
<CODE><PRE>
  a = BigDecimal.E(20)
  c = a * "0.123456789123456789123456789" # A String is changed to BigDecimal object.
</PRE></CODE>
is performed normally.<BR>
 But,because String does not have coerce method,the following example can not be performed.<BR>

<CODE><PRE>
  a = BigDecimal.E(20)
  c = "0.123456789123456789123456789" * a # ERROR
</PRE></CODE>

If you actually have any inconvenience about the error above.
You can define a new class derived from String class,
and define coerce method within the new class.<BR>

<hr>
<A NAME="#UNDEF">
<H2>Infinity,Not a Number(NaN),Zero</H2>
Infinite numbers and NaN can be represented by string writing "+Infinity"(or "Infinity"),"-Infinity",and "NaN" respectively in your program.
Infinite numbers can be obtained by 1.0/0.0(=Infinity) or -1.0/0.0(=-Infinity).
<BR><BR>
NaN(Not a number) can be obtained by undefined computation like 0.0/0.0 
or Infinity-Infinity.
Any computation including NaN results to NaN.
Comparisons with NaN never become true,including comparison with NaN itself.
<BR><BR>
Zero has two different variations as +0.0 and -0.0.
But,still, +0.0==-0.0 is true.
<BR><BR>
Computation results including Infinity,NaN,+0.0 or -0.0 become complicated.
Run following program and comfirm the results.
Send me any incorrect result if you find.

<PRE><CODE>
 require "bigdecimal"
 aa  = %w(1 -1 +0.0 -0.0 +Infinity -Infinity NaN)
 ba  = %w(1 -1 +0.0 -0.0 +Infinity -Infinity NaN)
 opa = %w(+ - * / <=> > >=  < == != <=)
 for a in aa
  for b in ba
    for op in opa
      x = BigDecimal::new(a)
      y = BigDecimal::new(b)
      eval("ans= x #{op} y;print a,' ',op,' ',b,' ==> ',ans.to_s,\"\n\"")
    end
  end
 end
</CODE></PRE>
<hr>

<A NAME="#STRUCT">
<H2>Internal structure</H2>
BigDecimal number is defined by the structure Real in BigDecimal.h.
Digits representing a float number are kept in the array frac[] defined in the structure.
In the program,any floating number(BigDecimal number) is represented as:<BR>
 <BigDecimal number> = 0.xxxxxxxxx*BASE**n<BR><BR>
where 'x' is any digit representing mantissa(kept in the array frac[]),
BASE is base value(=10000 in 32 bit integer system),
and n is the exponent value.<BR>
Larger BASE value enables smaller size of the array frac[],and increases computation speed.
The value of BASE is defined ind VpInit(). In 32 bit integer system,this value is 
10000. In 64 bit integer system,the value becomes larger.
BigDecimal has not yet been compiled and tested on 64 bit integer system.
It will be very nice if anyone try to run BigDecimal on 64 bit system and
 inform me the results.
When BASE is 10000,an element of the array frac[] can have vale of from 0 to 9999.
(up to 4 digits).<BR>
The structure Real is defined in bigdecimal.h as:<BR>
<CODE><PRE>
  typedef struct {
     VALUE  obj;     /* Back pointer(VALUE) for Ruby object.         */
     unsigned long MaxPrec; /* The size of the array frac[]          */
     unsigned long Prec;    /* Current size of frac[] actually used. */
     short    sign;         /* Attribute of the value.  */
                            /*  ==0 : NaN               */
                            /*    1 : +0                */
                            /*   -1 : -0                */
                            /*    2 : Positive number   */
                            /*   -2 : Negative number   */
                            /*    3 : +Infinity         */
                            /*   -3 : -Infinity         */
     unsigned short flag;   /* Control flag             */
     int      exponent;     /* Exponent value(0.xxxx*BASE**exponent) */
     unsigned long frac[1]; /* An araay holding mantissa(Variable)   */
  } Real;
</CODE></PRE>
The decimal value 1234.56784321 is represented as(BASE=10000):<BR>
<PRE>
    0.1234 5678 4321*(10000)**1
</PRE>
where frac[0]=1234,frac[1]=5678,frac[2]=4321,
Prec=3,sign=2,exponent=1. MaxPrec can be any value greater than or equal to 
Prec.
<hr>

<A NAME="#BASE">
<H2>Binary or decimal number representation</H2>
I adopted decimal number representation for BigDecimal implementation.
Of cource,binary number representation is common on the most computers.

<H3>Advantages using decimal representation</H3>
The reason why I adopted decimal number representation for BigDecimal is:<BR>
<DL>
<DT>Easy for debugging
<DD>The floating number 1234.56784321 can be easily represented as:<BR>
  frac[0]=1234,frac[1]=5678,frac[2]=4321,exponent=1,and sign=2.
<DT>Exact representation
<DD>Following program can add all numbers(in decimal) in a file
 without any error(no round operation).<BR>

<PRE><CODE>
   file = File::open(....,"r")
   s = BigDecimal::new("0")
   while line = file.gets
      s = s + line
   end
</CODE></PRE>

If the internal representation is binary,translation from decimal to 
binary is required and the translation error is inevitable.
For example, 0.1 can not exactly be represented in binary.<BR>
0.1 => b1*2**(-1)+b1*2**(-2)+b3*2**(-3)+b4*2**(-4)....<BR>
where b1=0,b2=0,b3=0,b4=1...<BR>
bn(n=1,2,3,...) is infinite series of digit with value of 0 or 1,
and rounding operation is necessary but where we should round the series ?
Of cource,exact "0.1" is printed if the rouding operation is properly done,
<DT>Significant digit we can have is automatically determined
<DD>In binary representation,0.1 can not be represented in finite series of digit.

But we only need one element(frac[0]=1) in decimal representation.
This means that we can always determine the size of the array frac[] in Real 
structure.
</DL>

<H3>Disadvantage of decimal representation</H3>
Advantages stated so far can also be disadvantages if the input from outside is
 represented in binary.
Translation error from decimal to binary or vice versa is inevitable.
So,translation from Float(binary) to BigDecimal(decimal) is not alway done exactly.

<H4>Which is the first input?</H4>
Because most people uses decimal notatin for numeric data representation,
BigDecimal can handle numeric data without loss of translation error.
<hr>

<A NAME="#PREC">
<H2>Resulting number of significant digits</H2>
For the fundamental arithmetics such as addition,subtraction,
multiplication,and division,I prepared 2 group of methods<BR>

<H3>1. +,-,*,/</H3>
For the operation + - * /,you can not specify the resulting 
number of significant digits.<BR>
Resulting number of significant digits are defined as:<BR>
1.1 For * and /,resulting number of significant digits is the sum of the 
significant digits of both side of the operator.<BR>
1.2 For + and -,resulting number of significant digits is determined so that
 no round operation is needed. <br>
For example, c has more than 100 siginificant digits if c is computed as:<BR>
c = 0.1+0.1*10**(-100)<br>
<BR>
As +,-,and * are always exact(no round operation is performed),
which means more momories are required to keep computation results.

As for the division as c = a/b,the significant digits of c is the same 
as a*b. Division such as c=1.0/3.0 will be rounded.<BR>

<H3>2. assign,add,sub,mult,div</H3>
The length of the significant digits obtained from +,-,*,/ 
is always defined by that of right and left side of the operator.
To specify the length of the significant digits by your self,
use methos assign,add,sub,mult,div, or limit(class method).
Following example compute the ratio of the circumference of a circle to 
its dirmeter(pi=3.14159265358979....) using J.Machin's formula.
<BR><BR>
<CODE><PRE>
#!/usr/local/bin/ruby

#
# pai.rb
#  USAGE: ruby pai.rb n
#   where n is the number of digits required.
#  EX.: ruby pai.rb 1000
#

require "bigdecimal"
#
# Calculates 3.1415.... using J. Machin's formula.
#
def pai(sig) # sig: Number of significant figures
  exp    = -sig
  pi     = BigDecimal::new("0")
  two    = BigDecimal::new("2")
  m25    = BigDecimal::new("-0.04")
  m57121 = BigDecimal::new("-57121")

  u = BigDecimal::new("1")
  k = BigDecimal::new("1")
  w = BigDecimal::new("1")
  t = BigDecimal::new("-80")
  while (u.exponent >= exp) 
    t   = t*m25
    u,r = t.div(k,sig)
    pi  = pi + u
    k   = k+two
  end

  u = BigDecimal::new("1")
  k = BigDecimal::new("1")
  w = BigDecimal::new("1")
  t = BigDecimal::new("956")
  while (u.exponent >= exp )
    t,r = t.div(m57121,sig)
    u,r = t.div(k,sig)
    pi  = pi + u
    k   = k+two
  end
  pi
end

if $0 == __FILE__
  print "PAI("+ARGV[0]+"):\n"
  p pai(ARGV[0].to_i)
end

</PRE></CODE>
<HR>
<FONT size=2>
<I>
<A HREF="http://www.tinyforest.gr.jp">
Shigeo Kobayashi
</A>
(E-Mail:<A HREF="mailto:shigeo@tinyforest.gr.jp">&lt;shigeo@tinyforest.gr.jp&gt;</U></A>)
</I>
</FONT>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
